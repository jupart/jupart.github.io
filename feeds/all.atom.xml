<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>jupart</title><link href="https://jupart.github.io/" rel="alternate"></link><link href="https://jupart.github.io/feeds/all.atom.xml" rel="self"></link><id>https://jupart.github.io/</id><updated>2018-01-23T00:00:00-05:00</updated><entry><title>Attractor - a game about magnetism</title><link href="https://jupart.github.io/attractor-release.html" rel="alternate"></link><published>2018-01-23T00:00:00-05:00</published><updated>2018-01-23T00:00:00-05:00</updated><author><name>jupart</name></author><id>tag:jupart.github.io,2018-01-23:/attractor-release.html</id><summary type="html">&lt;p class="first last"&gt;A game about magnetism, made using Kivent, able to deploy to Android mobile devices&lt;/p&gt;
</summary><content type="html">&lt;p&gt;&lt;em&gt;The attractor floats in space. A nearby planet tugs the tiniest of tugs, the
Pull, setting the attractor on a collision course with a
multi-story facility experimenting with a new technology: monopole magnets.
Still feeling the Pull, the attractor seeks to escape the facility and meet its
final resting place at the nearest pole of the planet.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Magnets are such fascinating things. They have the ability to exert force on
other objects via an invisible hand. I was working on a separate project when I
had an idea: a game where the inputs only change a magnet's pole. Attractor is
the game I made with this in mind.&lt;/p&gt;
&lt;p&gt;While associating talk of magnets with
charge is techincally incorrect, I thought it would be simpler and easier to
understand if I used the terms magnet and charge instead of electric dipole and
north and south pole, so that's what I'll use in this post.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="gameplay"&gt;
&lt;h2&gt;Gameplay&lt;/h2&gt;
&lt;p&gt;In Attractor, you control the polarity of an impossibility: a monopole
magnet that can change its charge at will. Using three simple buttons on your
phone or screen you can set your attractor to positive, negative, or neutral
charge. The buttons cover the play area and are transparent, but the outline of
each button can be seen at the edge of said area. Depending on the magnets
around the attractor, it will be pulled,
pushed, or left alone to float on its current trajectory. Positive (red) repels
positive and attracts negative (blue), neutral (grey) floats.&lt;/p&gt;
&lt;p&gt;The attractor's goal is to reach the end of the current level, marked by the
hole in the floor. Each level has an ideal number of charge changes and an
ideal time taken to completion. The Reset button sends the attractor back to
the beginning of the current level.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Game Objects&lt;/strong&gt;&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Magnet - simple stationary monopole magnet that pulls or pushes the attractor&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="Magnet" class="align-center" src="images/attractor/posipole_on_first_level_with_yellow_finish.png" style="width: 324.0px; height: 576.0px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Rotator - rotating Magnet&lt;/li&gt;
&lt;li&gt;Membrane - an object that lets the attractor through only if its color
matches the charge/color of the Membrane&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="Membrane" class="align-center" src="images/attractor/membrane_element.png" style="width: 324.0px; height: 576.0px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Changer - an object that changes the charge/color of the attractor to match
its own&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;img alt="Changer" class="align-center" src="images/attractor/changer_element.png" style="width: 324.0px; height: 576.0px;" /&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="code-stuff"&gt;
&lt;h2&gt;Code stuff&lt;/h2&gt;
&lt;p&gt;I'm an amateur programmer at best, so the &lt;a class="reference external" href="https://github.com/jupart/attractor"&gt;project&lt;/a&gt; should just serve as an
example of what you could do, not what you should do. There are some pretty
serious separation of concerns issues in the code design I would refactor out
if I had the time!&lt;/p&gt;
&lt;p&gt;Attractor uses &lt;a class="reference external" href="https://github.com/kivy/kivy"&gt;Kivy&lt;/a&gt; for its UI elements like buttons, menus, layouts, etc. Kivy
is a really awesome framework that lets you define UI stuffs in Python or its
own .kv description files.&lt;/p&gt;
&lt;p&gt;Attractor uses &lt;a class="reference external" href="https://github.com/kivy/kivent"&gt;Kivent&lt;/a&gt; as its ECS. Kivent lets you prototype systems as Python
classes and later refit them to Cython for better performance if needed. The
most important system in this game, &lt;a class="reference external" href="https://github.com/jupart/attractor/blob/develop/ChargeSystem.py"&gt;ChargeSystem.py&lt;/a&gt;, is a good example of what
you can do with Kivent.&lt;/p&gt;
&lt;p&gt;Kivent has a builtin module for using &lt;a class="reference external" href="https://github.com/tito/cymunk"&gt;Cymunk&lt;/a&gt;, which is a &lt;a class="reference external" href="https://github.com/slembcke/Chipmunk2D"&gt;Chipmunk2D&lt;/a&gt; wrapper
for Cython. Attractor uses this for collision detection and correction and to
apply forces to the attractor.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="what-i-m-kind-of-proud-of"&gt;
&lt;h2&gt;What I'm kind of proud of&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;I didn't use Kivent's builtin Animation System, but instead used
&lt;tt class="docutils literal"&gt;kivy.animation&lt;/tt&gt; on simple &lt;tt class="docutils literal"&gt;kivy.graphics&lt;/tt&gt; objects like &lt;tt class="docutils literal"&gt;Ellipses&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;Rectangles&lt;/tt&gt;. This way I was able to make art changes via code by changing
the way the shapes and colors were defined.&lt;/li&gt;
&lt;li&gt;Entities were defined via &lt;a class="reference external" href="https://github.com/jupart/attractor/blob/develop/resources/entities.json"&gt;json&lt;/a&gt;. I wrote &lt;a class="reference external" href="https://github.com/jupart/attractor/blob/develop/EntityFactory.py"&gt;EntityFactory.py&lt;/a&gt; to load this file
and build Kivent entities, which let me abstract away the kind of difficult to use
Kivent &lt;tt class="docutils literal"&gt;gameworld.init_entity()&lt;/tt&gt; args.&lt;/li&gt;
&lt;li&gt;The Charge System idea, the core of the game&lt;/li&gt;
&lt;li&gt;The level editor isn't completely horrible. Levels are stored as json
files, not really anything special I think. I store a location, rotation, and
entity name that EntityFactory builds with, so there isn't any saved state of
levels.&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="issues-i-ran-into"&gt;
&lt;h2&gt;Issues I ran into&lt;/h2&gt;
&lt;p&gt;It is so cool to be able to make performant apps and games using Python via
Kivy and Kivent. That being said, it can be pretty painful when it comes time
to deploy.&lt;/p&gt;
&lt;p&gt;The distribution story with Python, Kivy, and Kivent (in combination) is a
little rough. I have another post about getting my development environment
going &lt;a class="reference external" href="kivent_to_android.html"&gt;here&lt;/a&gt;. In general, while &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; gets the job done for Android
deployment, often times it feels like a brittle tool. For example,
currently I can't put together an .apk for you to try out because of &lt;a class="reference external" href="https://github.com/kivy/buildozer/issues/312"&gt;this&lt;/a&gt; issue.&lt;/p&gt;
&lt;p&gt;Kivent is great, but the Cython/Python interaction can sometimes lead to errors
that are very hard to debug. Crashes with cryptic exception messages will be
frequent when getting started up with Kivent. Here's an example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;File &amp;quot;/home/jupart/Code/Python/attractor/EntityFactory.py&amp;quot;, line 73, in create_entity_at&lt;/span&gt;
&lt;span class="go"&gt;    return self.gameworld.init_entity(new_ent_data[0], new_ent_data[1])&lt;/span&gt;
&lt;span class="go"&gt;File &amp;quot;kivent_core/gameworld.pyx&amp;quot;, line 428, in kivent_core.gameworld.GameWorld.init_entity (kivent_core/gameworld.c:8899)&lt;/span&gt;
&lt;span class="go"&gt;File &amp;quot;kivent_core/managers/system_manager.pyx&amp;quot;, line 163, in kivent_core.managers.system_manager.SystemManager.__getitem__ (kivent_core/managers/system_manager.c:2441)&lt;/span&gt;
&lt;span class="go"&gt;    IndexError: list index out of range&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Yikes! Make sure when you call &lt;tt class="docutils literal"&gt;self.gameworld.init_entity(components, component_order)&lt;/tt&gt;,
that all of the components' names are right and are in the right order! It's a
common error until you set up something like an EntityFactory which abstracts
that bit away.&lt;/p&gt;
&lt;p&gt;If you run into crashes when running your app on your device, &lt;tt class="docutils literal"&gt;buildozer android logcat&lt;/tt&gt;
(or the &lt;tt class="docutils literal"&gt;adb&lt;/tt&gt; equivalent) is a useful tool for getting debug information on
what's causing the crash. I fooled around for a while trying to fix a crash
that was caused by one of my music tracks being 24-bit .wav (or something like
that). Getting debug via &lt;tt class="docutils literal"&gt;logcat&lt;/tt&gt; and re-encoding the tracks to 16-bit .wav
did the trick.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="current-status"&gt;
&lt;h2&gt;Current status&lt;/h2&gt;
&lt;p&gt;This project has sat for a while. I started it in May 2017 and haven't touched
it since October 2017. I wrote the program, made the art, and wrote/performed
the music myself. The menu design
and general UI could use a bit of work, but overall I think the game is fun and
I like where the project stands today. All told, there are 16 levels in sets of
4 where each set focuses on a new game element. I hope the project serves as an
example of what you can accomplish with Python/Kivy/Kivent on mobile and
desktop machines.&lt;/p&gt;
&lt;p&gt;I don't plan on updating the game any time soon, so I've released the code and
art on Github under the MIT license.&lt;/p&gt;
&lt;p&gt;The music tracks are also on Github, but I reserve rights to
those. Feel free to install on your own device to try out the game or download
and listen to the tracks, though. If I can get the &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; script working
again I'll probably put up a Github release for the .apk, too.&lt;/p&gt;
&lt;/div&gt;
</content><category term="kivent"></category><category term="python"></category><category term="buildozer"></category><category term="kivy"></category><category term="android"></category><category term="cymunk"></category></entry><entry><title>Setting up to deploy Kivent to Android</title><link href="https://jupart.github.io/kivent_to_android.html" rel="alternate"></link><published>2017-08-03T00:00:00-05:00</published><updated>2017-08-03T00:00:00-05:00</updated><author><name>jupart</name></author><id>tag:jupart.github.io,2017-08-03:/kivent_to_android.html</id><summary type="html">&lt;p class="first last"&gt;Steps to set up Python, Kivy, Kivent, and Cymunk for use with Android devices&lt;/p&gt;
</summary><content type="html">&lt;p&gt;I recently put together a new machine and needed to get my python toolchain
back up and running, so I decided to record the needed steps and post them
here.&lt;/p&gt;
&lt;p&gt;This post assumes your requirements are the same as mine, that your goal is to deploy apps
that make use of Python 2.7, Kivy, Kivent's core, and Kivent's physics module (via Cymunk
via Chipmunk2D) to Android.&lt;/p&gt;
&lt;p&gt;I use Debian-based Linux distributions, like Ubuntu, so my dependencies will be installed
via &lt;tt class="docutils literal"&gt;apt&lt;/tt&gt;. My workflow is to write the core of my app, run and test on my
desktop/laptop machine, and then begin to deploy to my Android device for
testing and improvements.&lt;/p&gt;
&lt;p&gt;First, lets make sure we have &lt;tt class="docutils literal"&gt;pip&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;kivy&lt;/tt&gt;'s dependencies, and &lt;tt class="docutils literal"&gt;virtualenv&lt;/tt&gt;,
which we use to house our python modules used for development for our project.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo apt install python-pip build-essential git python python-dev ffmpeg libsdl2-dev libsdl2-image-dev libsdl2-mixer-dev libsdl2-ttf-dev libportmidi-dev libswscale-dev libavformat-dev libavcodec-dev zlib1g-dev
&lt;span class="gp"&gt;$&lt;/span&gt; sudo pip install virtualenv
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;After we've set up and &lt;tt class="docutils literal"&gt;source&lt;/tt&gt;'d our &lt;tt class="docutils literal"&gt;virtualenv&lt;/tt&gt;, we can install
&lt;tt class="docutils literal"&gt;cython&lt;/tt&gt; and then &lt;tt class="docutils literal"&gt;kivy&lt;/tt&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; project_path
&lt;span class="gp"&gt;$&lt;/span&gt; virtualenv project_env
&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;source&lt;/span&gt; project_path/project_env/bin/activate
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; pip install cython kivy
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;kivent&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;cymunk&lt;/tt&gt; are not installable via pip at the time of this writing, so next,
we need to clone their repositories off of github into a local folder (I typically store my
tools in ~/Tools). We'll run their respective &lt;tt class="docutils literal"&gt;setup.py&lt;/tt&gt;'s using &lt;tt class="docutils literal"&gt;python&lt;/tt&gt; specific to
the &lt;tt class="docutils literal"&gt;virtualenv&lt;/tt&gt; we just created.&lt;/p&gt;
&lt;p&gt;Note that &lt;tt class="docutils literal"&gt;kivent&lt;/tt&gt; contains several modules (core, cymunk, particles, etc.), so you'll
want to install the ones you need for your project. I'm only using kivent_core
and kivent_cymunk. You may be wondering why you need to install &lt;tt class="docutils literal"&gt;cymunk&lt;/tt&gt; and
&lt;tt class="docutils literal"&gt;kivent_cymunk&lt;/tt&gt;. This is because &lt;tt class="docutils literal"&gt;cymunk&lt;/tt&gt; is a module that supplies python
bindings to a C-based library called Chipmunk2D. &lt;tt class="docutils literal"&gt;kivent_cymunk&lt;/tt&gt; builds on
that by adding a game system you can use to apply physics to your entities.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ~/Tools
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; git clone https://github.com/kivy/kivent.git
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; git clone https://github.com/tito/cymunk

&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; cymunk
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; python setup.py build_ext install

&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ../kivent/modules/core
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; python setup.py build_ext install

&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; ../cymunk
&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; python setup.py build_ext install
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;At this point, we can run our code and test on our desktop/laptop machines as
needed. To deploy to our Android device, we'll need a tool called
&lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Note that &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; is installed system-wide. It has nothing to do with
your modules we've installed up til now. &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; reads your
&lt;tt class="docutils literal"&gt;buildozer.spec&lt;/tt&gt; in your project's root directory and downloads the modules
and tools it needs based on the information contained in it.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;(project_env) $&lt;/span&gt; deactivate

&lt;span class="gp"&gt;$&lt;/span&gt; sudo pip install cython
&lt;span class="gp"&gt;$&lt;/span&gt; sudo pip install buildozer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In order to build your project, it needs a Java compiler. Normally, we'd use
&lt;tt class="docutils literal"&gt;openjdk&lt;/tt&gt; for this, but the Android SDK that &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; downloads uses
source version 1.5, which is deprecated and &lt;tt class="docutils literal"&gt;openjdk&lt;/tt&gt; won't compile it. So
instead, lets get Oracle's jdk, which complains, but will compile.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo add-apt-repository ppa:webupd8team/java
&lt;span class="gp"&gt;$&lt;/span&gt; sudo apt update
&lt;span class="gp"&gt;$&lt;/span&gt; sudo apt install oracle-java8-installer
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Next, grab the 32-bit libraries &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt; requires.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; sudo apt-get install build-essential ccache git libncurses5:i386 libstdc++6:i386 libgtk2.0-0:i386 libpangox-1.0-0:i386 libpangoxft-1.0-0:i386 libidn11:i386 python2.7 python2.7-dev unzip zlib1g-dev zlib1g:i386
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We need to add udev rules specific to your device. This lets you deploy
your app to your Android device.  Find your device id by typing &lt;tt class="docutils literal"&gt;lsusb&lt;/tt&gt; into
your terminal with your Android device plugged in via USB. If you run the command
before and after plugging in your device, you should notice your device in the
difference between the two. My device in &lt;tt class="docutils literal"&gt;lusb&lt;/tt&gt; looks like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;Bus 001 Device 003: ID 18d1:4ee7 Google Inc.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You need to add a line to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;/etc/udev/rules.d/51-android.rules&lt;/span&gt;&lt;/tt&gt; (and create that
file if it doesn't already exist) resembling the following:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="go"&gt;SUBSYSTEM==&amp;quot;usb&amp;quot;, ATTR{idVendor}==&amp;quot;18d1&amp;quot;, MODE=&amp;quot;0666&amp;quot;, GROUP=&amp;quot;plugdev&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where &lt;tt class="docutils literal"&gt;18d1&lt;/tt&gt; is your device's idVendor (mine was &lt;tt class="docutils literal"&gt;18d1&lt;/tt&gt;, as it's a Google
device). It's also covered &lt;a class="reference external" href="https://developer.android.com/studio/run/device.html"&gt;here&lt;/a&gt;.
&lt;tt class="docutils literal"&gt;sudo udevadm control &lt;span class="pre"&gt;--reload-rules&lt;/span&gt; &amp;amp;&amp;amp; udevadm trigger&lt;/tt&gt; reloads your udev rules.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; lsusb
&lt;span class="gp"&gt;$&lt;/span&gt; sudo vim /etc/udev/rules.d/51-android.rules
&lt;span class="gp"&gt;$&lt;/span&gt; sudo udevadm control --reload-rules &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; udevadm trigger
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Lets get back to our project's path, initialize the directory to use &lt;tt class="docutils literal"&gt;buildozer&lt;/tt&gt;,
and edit our &lt;tt class="docutils literal"&gt;buildozer.spec&lt;/tt&gt; file.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; project_path
&lt;span class="gp"&gt;$&lt;/span&gt; buildozer init
&lt;span class="gp"&gt;$&lt;/span&gt; vim buildozer.spec
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You'll want to change your &lt;tt class="docutils literal"&gt;buildozer.spec&lt;/tt&gt; file for each project, focusing
on the &lt;tt class="docutils literal"&gt;requirements&lt;/tt&gt; tag contained within. Now you should be able to run the
following command to deploy your app on your device!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;$&lt;/span&gt; buildozer android debug deploy
&lt;/pre&gt;&lt;/div&gt;
</content><category term="kivent"></category><category term="python"></category><category term="buildozer"></category><category term="kivy"></category><category term="android"></category><category term="cymunk"></category></entry></feed>